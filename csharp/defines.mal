(defmacro! fn (fn* [args body & rest]
  (if (empty? rest)
    `(fn* ~args ~body)
    `(fn* ~args (do ~body ~@rest)))))

(defmacro! let (fn* [vars body & rest]
  (if (empty? rest)
    `(let* ~vars ~body)
    `(let* ~vars (do ~body ~@rest)))))

(defmacro! defmacro (fn* [name args & body]
  `(defmacro! ~name (fn ~args ~@body))))

(defmacro def [& args]
  `(def! ~@args))

(defmacro defn [name args & body]
  `(def! ~name (fn ~args ~@body)))

(defn identity [x]
  x)

(def gensym
  (let [counter (atom 0)]
    (fn []
      (symbol (str "G__" (swap! counter + 1))))))

(defmacro time [exp]
  (let [start (gensym)
        ret   (gensym)]
    `(let [~start (time-ms)
           ~ret   ~exp]
       (println "Elapsed time:" (- (time-ms) ~start) "ms")
       ~ret)))

(defmacro cond [& xs]
  (let [cnt (count xs)]
    (if (= cnt 0) nil
      (if (< cnt 2)
        (throw "cond - even number of forms is required")
        `(if ~(first xs) ~(nth xs 1)
           (cond ~@(rest (rest xs))))))))

(defmacro when [tst body & rest]
  (if (empty? rest)
      `(if ~tst ~body)
      `(if ~tst (do ~body ~@rest))))

(defmacro unless [tst body & rest]
  (if (empty? rest)
    `(if ~tst nil ~body)
    `(if ~tst nil (do ~body ~@rest))))

(defmacro or [& xs]
  (if (empty? xs)
    false
    (let [sym (gensym)]
      `(let [~sym ~(first xs)]
         (if ~sym ~sym (or ~@(rest xs)))))))

(defmacro and [& xs]
  (if (empty? xs) true
    (if (empty? (rest xs))
      `(do ~@xs)
      `(if ~(first xs) (and ~@(rest xs)) false))))

(defn not [x]
  (if x false true))

(defn inc [n]
  (+ n 1))

(defn dec [n]
  (- n 1))

(defn zero? [n]
  (= 0 n))
