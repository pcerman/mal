(define-structure nil)
(define-structure closure  vars rest-var env body)
(define-structure atom     value)
(define-structure macro    fun)
(define-structure mal.exc  value)

(define nil (make-nil))

(define (create-closure env args body)
  (let loop ((args args)
             (vars '())
             (rest #f))
    (cond ((null? args)
               (when (eq? rest '&)
                 (error "fn* - missing rest argument"))
               (make-closure (reverse vars) rest env body))
          ((not (symbol? (car args)))
               (error "fn* - symbol expected for argument"))
          ((eq? rest '&)
               (when (eq? (car args) '&)
                 (error "fn* - incorect name for the rest argument"))
               (loop (cdr args) vars (car args)))
          (rest
               (error "fn* - multiple rest arguments"))
          ((eq? (car args) '&)
               (loop (cdr args) vars '&))
          (else
               (loop (cdr args) (cons (car args) vars) rest)))))

(define (closure-clone cls)
  (make-closure (closure-vars cls)
                (closure-rest-var cls)
                (closure-env cls)
                (closure-body cls)))

(define (create-closure-env cls args)
  (let ((c-env (create-env (closure-env cls))))
    (let loop ((vars (closure-vars cls)) (args args))
      (cond ((null? args)
                 (unless (null? vars)
                   (error "fn* - not enough function call arguments"))
                 (when (closure-rest-var cls)
                   (env-set! c-env (closure-rest-var cls) '())))
            ((null? vars)
                 (unless (closure-rest-var cls)
                   (error "fn* - too many function call arguments"))
                 (env-set! c-env (closure-rest-var cls) args))
            (else
                 (env-set! c-env (car vars) (car args))
                 (loop (cdr vars) (cdr args)))))
    c-env))

(define (closure-apply cls args fn-eval)
  (EVAL (closure-body cls)
        (create-closure-env cls args)))

(define (closure-args cls)
  (if (closure-rest-var cls)
    (append (closure-vars cls) (list '& (closure-rest-var cls)))
    (closure-vars cls)))

(define (macro-clone mac)
  (make-macro (macro-fun mac)))
